// This file is autogenerated.
// Do not modify this file as changes may be overwritten.
// Generated with settings: {{ size }}

// available types are:
// 8 bit: byte ubyte bool
// 16 bit: short ushort
// 32 bit: int uint float
// 64 bit: long ulong double

{%- macro vector(name, field, rows) -%}
// {{ rows }}, 1 ({{ size[rows] }}, 1) matrix
struct {{name}} {
{%- for i in range(size[rows]) %}
    {{ field }}{{ i }}:double;
{%- endfor %}
}
{%- endmacro %}

{%- macro matrix(name, field, rows, cols) -%}
// {{ rows }}, {{ cols }} ({{ size[rows] }}, {{ size[cols] }}) matrix
struct {{name}} {
{%- for i in range(size[rows]) %}
{%- for j in range(size[cols]) %}
    {{ field }}{{ i }}{{ j }}:double;
{%- endfor %}
{%- endfor %}
}
{%- endmacro %}

{%- macro symmetric(name, field, rows) -%}
// {{ rows }}, {{ rows }} ({{ size[rows] }}, {{ size[rows] }}) symmetric matrix
struct Symmetric{{name}} {
{%- for i in range(size[rows]) %}
{%- for j in range(size[rows]) if j >= i %}
    {{ field }}{{ i }}{{ j }}:double;
{%- endfor %}
{%- endfor %}
}
{%- endmacro %}

namespace fbs;

{{ vector('State', 'x', 'n') }}

{{ vector('Input', 'u', 'm') }}

{{ vector('Output', 'y', 'l') }}

{{ vector('AuxiliaryState', 'x', 'p') }}

{{ matrix('SecondOrderMatrix', 'm', 'o', 'o') }}

{{ matrix('LqrGainMatrix', 'k', 'm', 'n') }}

{{ matrix('KalmanGainMatrix', 'k', 'n', 'l') }}

{{ matrix('StateMatrix', 'a', 'n', 'n') }}

{{ matrix('InputMatrix', 'b', 'n', 'm') }}

{{ matrix('OutputMatrix', 'c', 'l', 'n') }}

{{ matrix('FeedthroughMatrix', 'd', 'l', 'm') }}

{{ symmetric('StateMatrix', 'q', 'n') }}

{{ symmetric('InputMatrix', 'r', 'm') }}

{{ symmetric('OutputMatrix', 'r', 'l') }}

table Kalman {
    state_estimate:State;
    error_covariance:SymmetricStateMatrix;
    process_noise_covariance:SymmetricStateMatrix;
    measurement_noise_covariance:SymmetricOutputMatrix;
    kalman_gain:KalmanGainMatrix;
}

table Lqr {
    horizon:uint;
    reference:State;
    state_cost:SymmetricStateMatrix;
    input_cost:SymmetricInputMatrix;
    horizon_cost:SymmetricStateMatrix;
    lqr_gain:LqrGainMatrix;
    integral_cost:SymmetricStateMatrix;
    integral:State;
}

table Bicycle {
    v:double;
    dt:double;
    M:SecondOrderMatrix;
    C1:SecondOrderMatrix;
    K0:SecondOrderMatrix;
    K2:SecondOrderMatrix;
    Ad:StateMatrix;
    Bd:InputMatrix;
    Cd:OutputMatrix;
    Dd:FeedthroughMatrix;
}

table Sample {
    timestamp:uint;
    computation_time:double;
    bicycle:Bicycle;
    kalman:Kalman;
    lqr:Lqr;
    state:State; // true state
    input:Input; // applied input
    output:Output; // output without noise
    measurement:Output; // output with noise
    auxiliary_state:AuxiliaryState; // auxiliary state
}

root_type Sample;
